#!/usr/bin/env python
#
# Author:  Fabien Hochstrasser <fabien.hochstrasser@swisscom.com>
# Date:    2017-09-27
# Purpose: Find the revoked certificates missing on the latest CRLs
#          generated by RSA and generate bash scripts to revoke them
#
# Usage: ./revoke_missing.py
#
import ldif
import os
import subprocess

from collections import namedtuple
from ConfigParser import SafeConfigParser
from datetime import datetime

SCRIPT_DIR = os.path.abspath(os.path.dirname(__file__))

CRL_DIR = os.path.join(SCRIPT_DIR, 'crls')
LDIF_DIR = os.path.join(SCRIPT_DIR, 'ldifs')
OUTPUT_DIR = os.path.join(SCRIPT_DIR, 'output')
CONFIG_FILE = os.path.join(SCRIPT_DIR, 'config.conf')
TOOLBOX_DIR = '/opt/ejbca/dist/clientToolBox'
REVOKE_CMD = 'https_proxy= ./ejbcaClientToolBox.sh EjbcaWsRaCli revokecert "{issuerdn}" {sn} {reason} {date}'

REASON_CODES = {
    'affiliationChanged': 'REV_AFFILIATIONCHANGED',
    'certificateHold': 'REV_UNSPECIFIED',
    'cessationOfOperation': 'REV_CESSATIONOFOPERATION',
    'keyCompromise': 'REV_KEYCOMPROMISE',
    'superseded': 'REV_SUPERSEDED',
    'unspecified': 'REV_UNSPECIFIED',
}


def main(config):
    # Reading the LDIF files is heavy
    # ldif_parsers keeps track of the LDIF files read and their content
    ldif_parsers = {}

    for issuer_dn in config.sections():
        crl_file = os.path.join(CRL_DIR, config.get(issuer_dn, 'crl'))
        ldif_file = os.path.join(LDIF_DIR, config.get(issuer_dn, 'ldif'))
        domain_ids = config.get(issuer_dn, 'domain_ids').split(',')
        output_file = os.path.join(OUTPUT_DIR, config.get(issuer_dn, 'output'))

        # Read the LDIF file only if not already done
        if not ldif_file in ldif_parsers:
            print('Parsing LDIF file ({ldif}) ...'.format(ldif=ldif_file))
            ldif_parsers[ldif_file] = LDIFRevoked(ldif_file)

        print('Parsing CRL file ({crl}) ...'.format(crl=crl_file))
        revoked_in_crl = CRLRevoked(crl_file).revoked
        revoked_in_ldif = ldif_parsers[ldif_file].revoked_for_domain_ids(domain_ids)
        missing_from_crl = set(revoked_in_ldif) - set(revoked_in_crl)

        print('Generating script ({script}) ...'.format(script=output_file))
        generate_revocation_script(output_file, issuer_dn, missing_from_crl)


def generate_revocation_script(output_file, issuer_dn, to_revoke):
    with open(output_file, 'w') as f:
        f.write('cd {dir}\n'.format(dir=TOOLBOX_DIR))
        for cert in to_revoke:
            f.write(REVOKE_CMD.format(
                issuerdn=issuer_dn,
                sn=cert.serial,
                reason=REASON_CODES[cert.reason],
                date='{}+00:00'.format(cert.instant.isoformat()),
            ))
            f.write('\n')


class LDIFRevoked(ldif.LDIFParser):
    """LDIF Parser which captures only the certificates which are revoked.

    You can access them using the 'revoked' attribute.
    """

    def __init__(self, ldif_file ):
        self.revoked = {}
        with open(ldif_file, 'r') as f:
            ldif.LDIFParser.__init__(self, f)
            self.parse()

    def revoked_for_domain_ids(self, domain_ids):
        r = []
        for domain_id in domain_ids:
            if domain_id in self.revoked:
                r.extend(self.revoked[domain_id])
        return r

    def handle(self, dn, entry):
        if not self._is_entry_revoked(entry):
            return

        serial = entry['rcm-0serial-2no'][0]
        reason = entry['rcm-0revocationReasonCode'][0]
        invalidity_date = entry['rcm-0invalidity-2dte'][0]
        invalidity_time = entry['rcm-0invalidity-2tim'][0]
        revocation_instant = datetime.strptime(invalidity_date + invalidity_time, '%Y%m%d%H%M%S')

        domain_id = entry['rcm-0domainID'][0]
        if domain_id not in self.revoked:
            self.revoked[domain_id] = []

        self.revoked[domain_id].append(RevokedCertificate(
            serial=serial,
            reason=reason,
            instant=revocation_instant,
        ))

    @staticmethod
    def _is_entry_revoked(entry):
        # A non-certificate entry cannot be revoked
        if 'rcm-0xudaClass' not in entry or 'xuda_certificate' not in entry['rcm-0xudaClass']:
            return False

        if 'rcm-0invalidity-2dte' in entry:
            return True

        return False


class CRLRevoked(object):

    def __init__(self, crl_file):
        self.crl_file = crl_file
        self.revoked = []
        self._parse()

    def _parse(self):
        """Parse the output of 'openssl crl -text'.

        And populates the 'revoked' attribute with RevokedCertificate instances.
        """
        cmd = ['openssl', 'crl', '-in', self.crl_file, '-noout', '-text']
        header_ended = False
        new_entry = None
        reason_code_on_next_line = False
        for line in subprocess.check_output(cmd).split('\n'):
            line = line.strip()

            if line.startswith('Revoked Certificates'):
                header_ended = True

            # The signature Algorithm is at the end of the CRL
            if header_ended and line.startswith('Signature Algorithm'):
                self.revoked.append(new_entry)
                break

            if line.startswith('Serial Number'):
                if new_entry:
                    self.revoked.append(new_entry)

                new_entry = RevokedCertificate(line.split(':')[1].strip())

            if line.startswith('Revocation Date'):
                date_str = ':'.join(line.split(':')[1:]).strip()
                new_entry.instant = datetime.strptime(date_str, '%b %d %H:%M:%S %Y GMT')

            if line.startswith('X509v3 CRL Reason Code'):
                reason_code_on_next_line = True
            elif reason_code_on_next_line:
                new_entry.reason = line


class RevokedCertificate(object):

    def __init__(self, serial, instant=None, reason=None):
        # Remove the leading zeroes (if any)
        self.serial = hex(int(serial, 16))[2:-1]
        self.instant = instant
        self.reason = reason

    def __eq__(self, other):
        """
        Two revoked certificate are equal
        if they have the same serial number and revocation instant.
        """
        return self.serial == other.serial

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return int(self.serial, 16)



if __name__ == '__main__':
    config = SafeConfigParser()
    config.read(CONFIG_FILE)
    main(config)
